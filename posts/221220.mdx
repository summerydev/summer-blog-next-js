---
title: JWT
date: 2022-12-20
description: json web tokenìœ¼ë¡œ ë¡œê·¸ì¸ ì¸ì¦ êµ¬í˜„
tag1: web
tag2: jwt
---

## â˜€ï¸ í´ë¼ì´ì–¸íŠ¸ ì¸ì¦ ë°©ì‹

ì„œë²„ê°€ í´ë¼ì´ì–¸íŠ¸ë¥¼ ì¸ì¦í•˜ëŠ” ë°©ì‹ : `cookie`, `session`, `token`

<br />

### 1. cookie

- Key-Value í˜•ì‹ì˜ ë¬¸ìì—´

#### ğŸª cookie ì¸ì¦ ë°©ì‹

1. í´ë¼ì´ì–¸íŠ¸ê°€ ì„œë²„ì— ìš”ì²­
2. ì„œë²„ê°€ ì‘ë‹µ ì‘ì„± ì‹œ íŠ¹ì • ì •ë³´ë¥¼ ì‘ë‹µ í—¤ë”ì˜ Set-Cookieì— ë‹´ìŒ
3. í´ë¼ì´ì–¸íŠ¸ëŠ” ìš”ì²­ì„ ë³´ë‚¼ ë•Œë§ˆë‹¤ ì €ì¥ëœ ì¿ ì¹´ë¥¼ ìš”ì²­ í—¤ë”ì˜ Cookieì— ë‹´ì•„ ë³´ëƒ„

#### ğŸª íŠ¹ì§•

- ìš”ì²­ ì‹œ ì¿ í‚¤ì˜ ê°’ì„ ê·¸ëŒ€ë¡œ ë³´ëƒ„ â†’ ë³´ì•ˆì— ì·¨ì•½
- ì¿ í‚¤ì˜ ìš©ëŸ‰ ì œí•œ
- ì›¹ ë¸Œë¼ìš°ì €ë§ˆë‹¤ ì¿ í‚¤ ì§€ì› í˜•íƒœ ë‹¤ë¦„ â†’ ë¸Œë¼ìš°ì €ê°„ ê³µìœ  ë¶ˆê°€ëŠ¥

<br />

### 2. session

- ë¯¼ê° ì •ë³´ë¥¼ ì„œë²„ ì¸¡ì— ì €ì¥í•˜ê³  ê´€ë¦¬í•˜ëŠ” ë°©ì‹(ì„œë²„ì˜ ë©”ëª¨ë¦¬, ì„œë²„ì˜ ë¡œì»¬íŒŒì¼, DB ë“±)
- Key(SESSION ID) + Value

#### ğŸŒ session ì¸ì¦ ë°©ì‹

1. ìœ ì €ê°€ ì›¹ì‚¬ì´íŠ¸ì—ì„œ ë¡œê·¸ì¸
2. í•´ë‹¹ ì„¸ì…˜ì´ SESSION IDë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì„œë²„ ë©”ëª¨ë¦¬ ë˜ëŠ” DBì— ì €ì¥
3. ì„œë²„ì—ì„œ ë¸Œë¼ìš°ì € ì¿ í‚¤ì— SESSION ID ì €ì¥
4. ë¸Œë¼ìš°ì €ëŠ” ëª¨ë“  ìš”ì²­ì— ì¿ í‚¤ì˜ SESSION ID ë‹´ì•„ ì „ì†¡
5. ìš”ì²­ì˜ SESSION IDì™€ ì„œë²„ì—ì„œ ê´€ë¦¬í•˜ëŠ” SESSION ID ë¹„êµ í›„ ì¸ì¦ ìˆ˜í–‰

#### ğŸŒ íŠ¹ì§•

- ìš”ì²­ ë§ì•„ì§€ë©´ ì„œë²„ì— ë¶€í•˜
- SESSION ID ìì²´ë¥¼ íƒˆì·¨ë‹¹í•˜ëŠ” ë¬¸ì œ

<br />
### 3. token - í´ë¼ì´ì–¸íŠ¸ê°€ ì„œë²„ì— ì ‘ì† ì‹œ ìœ ì¼í•œ ì¸ì¦ í† í° ë¶€ì—¬

#### ğŸª™ token ì¸ì¦ ë°©ì‹

1. ì‚¬ìš©ìê°€ ì•„ì´ë””ì™€ ë¹„ë°€ë²ˆí˜¸ë¡œ ë¡œê·¸ì¸
2. ì„œë²„ ì¸¡ì—ì„œ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ìœ ì¼í•œ í† í° ë°œê¸‰
3. í† í°ì„ ì¿ í‚¤ ë˜ëŠ” ìŠ¤í† ë¦¬ì§€ì— ì €ì¥, ì„œë²„ ìš”ì²­ í•  ë•Œë§ˆë‹¤ HTTPìš”ì²­ í—¤ë”ì— í¬í•¨ì‹œì¼œ ì „ë‹¬
4. ì„œë²„ëŠ” ì „ë‹¬ë°›ì€ í† í° ê²€ì¦, ìš”ì²­ ì‘ë‹µ

#### ğŸª™ íŠ¹ì§•

- ë³„ë„ì˜ ì €ì¥ì†Œ í•„ìš” ì—†ìŒ, DB ì¡°íšŒ ë¶ˆí•„ìš”
- Payload ìì²´ëŠ” ì•”í˜¸í™” ë˜ì§€ ì•ŠìŒ â†’ ìœ ì € ì¤‘ìš” ì •ë³´ ë‹´ì„ ìˆ˜ ì—†ìŒ
- í† í° íƒˆì·¨ ì‹œ ëŒ€ì²˜ í˜ë“¦ â†’ ì‚¬ìš© ê¸°ê°„ ì œí•œ ì„¤ì •

<br />

## â˜€ï¸ JWT

### JWTë€?

- JSON Web Token : ì¸ì¦ì— í•„ìš”í•œ ì •ë³´ë“¤ì„ ì•”í˜¸í™”ì‹œí‚¨ JSON í† í°
- `.` ì„ êµ¬ë¶„ìë¡œ ë‚˜ëˆ„ì–´ì§€ëŠ” ì„¸ ê°€ì§€ ë¬¸ìì—´ ì¡°í•©(Header, Payload, Signature)  
   ![jwtimg](/img/221220/1.png)
- Header : JWT ì—ì„œ ì‚¬ìš©í•  íƒ€ì…ê³¼ í•´ì‹œ ì•Œê³ ë¦¬ì¦˜ì˜ ì¢…ë¥˜
- Payload : ì„œë²„ì—ì„œ ì²¨ë¶€í•œ ì‚¬ìš©ì ê¶Œí•œ ì •ë³´ì™€ ë°ì´í„°
- Signature : Header, Payload ë¥¼ Base64 URL-safe Encode ë¥¼ í•œ ì´í›„ Header ì— ëª…ì‹œëœ í•´ì‹œí•¨ìˆ˜ë¥¼ ì ìš©í•˜ê³ , ê°œì¸í‚¤(Private Key)ë¡œ ì„œëª…í•œ ì „ìì„œëª…

### Access Token / Refresh Token

- Access Token (ì ‘ê·¼ì— ê´€ì—¬)
  - **í´ë¼ì´ì–¸íŠ¸**ê°€ ê°–ê³ ìˆëŠ” ì‹¤ì œë¡œ ìœ ì €ì˜ ì •ë³´ê°€ ë‹´ê¸´ í† í°
  - í´ë¼ì´ì–¸íŠ¸ì—ì„œ ìš”ì²­ì´ ì˜¤ë©´ ì„œë²„ì—ì„œ í•´ë‹¹ í† í°ì— ìˆëŠ” ì •ë³´ë¥¼ í™œìš©í•´ ì‚¬ìš©ì ì •ë³´ì— ë§ê²Œ ì‘ë‹µì„ ì§„í–‰
- Refresh Token (ì¬ë°œê¸‰ì— ê´€ì—¬)
  - ìƒˆë¡œìš´ Access Tokenì„ ë°œê¸‰í•´ì£¼ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” í† í°
  - ì§§ì€ ìˆ˜ëª…ì„ ê°€ì§€ëŠ” Access Tokenì—ê²Œ ìƒˆë¡œìš´ í† í°ì„ ë°œê¸‰í•´ì£¼ê¸° ìœ„í•´ ì‚¬ìš©
  - ë³´í†µ **ë°ì´í„°ë² ì´ìŠ¤**ì— ìœ ì € ì •ë³´ì™€ ê°™ì´ ê¸°ë¡

#### ğŸ’ ì›ë¦¬

![jwtimg](/img/221220/2.png)

1. ì²˜ìŒ ë¡œê·¸ì¸ ì„±ê³µ
2. ì„œë²„ : Access Token, Refresh Token ë™ì‹œ ë°œê¸‰, DBì— Refresh Tokenì €ì¥

   í´ë¼ì´ì–¸íŠ¸ : ì¿ í‚¤orì„¸ì…˜orì›¹ìŠ¤í† ë¦¬ì§€ì— Access Token, Refresh Token ì €ì¥

3. í´ë¼ì´ì–¸íŠ¸ api ìš”ì²­ ì‹œ í—¤ë”ì— í† í° ë‹´ì•„ ìš”ì²­ â†’ ì„œë²„ì—ì„œ í† í° ê²€ì¦
   - case1 : access token ë§Œë£Œ, refresh token ë§Œë£Œ **â†’** ì¬ ë¡œê·¸ì¸, ìƒˆë¡œ ë°œê¸‰
   - case2 : access token ë§Œë£Œ, refresh token ìœ íš¨ **â†’** refresh tokenì„ ê²€ì¦, access token ì¬ë°œê¸‰
   - case3 : access token ìœ íš¨, refresh token ë§Œë£Œ
     **â†’** ë°©ë²•1. access tokenì„ ê²€ì¦í•˜ì—¬ refresh token ì¬ë°œê¸‰
     â†’ ë°©ë²•2. ì¬ ë¡œê·¸ì¸, ìƒˆë¡œ ë°œê¸‰
   - case4 : access token ìœ íš¨, refresh token ìœ íš¨ **â†’** ì •ìƒ ì²˜ë¦¬
4. ë¡œê·¸ì•„ì›ƒ ì‹œ ì €ì¥ì†Œì—ì„œ Access token, Refresh Tokenì„ ì‚­ì œ
   <br />

---

## â˜€ï¸ JWT ì½”ë“œ ì ìš© 1

- axios interceptorsì˜ headerì— í† í°ì„ ë‘˜ ë‹¤ ë‹´ì•„ì„œ ë³´ë‚´ëŠ” ë°©ì‹
- ì²˜ìŒì—ëŠ” í¸í•˜ê²Œ í† í° ë‘ê°œ ë‹¤ ë³´ë‚´ì„œ ê²€ì¦í•˜ë ¤ê³  ì´ ë°©ì‹ì„ ì‚¬ìš©í•˜ì§€ë§Œ, ë³´ì•ˆìƒ ì´ ë°©ì‹ì€ í•˜ë©´ ì•ˆëœë‹¤.

### api

#### `secrityHandlers.js`

- ìš”ì²­ì´ ë“¤ì–´ì˜¬ ë•Œë§ˆë‹¤ í† í°ì„ ê²€ì¦, ì¬ë°œê¸‰, ì—ëŸ¬ í•¸ë“¤ë§

```jsx
const jwt = require("jsonwebtoken");
const sharedSecret = "hiJWT";
const securityHandlers = require("./securityHandlers");

exports.Bearer = function (req, authOrSecDef, token, callback) {
  function sendError() {
    return new Error("access denied!");
  }

  if (req.headers.authorization) {
    const accessToken = req.headers.authorization.split("|")[1];
    const refreshToken = req.headers.authorization.split("|")[2];

    const refreshVerify = (token) => {
      try {
        jwt.verify(token, sharedSecret);
        return true;
      } catch (e) {
        return false;
      }
    };

    jwt.verify(
      accessToken,
      sharedSecret,
      function (verificationError, decodedToken) {
        if (verificationError == null && decodedToken) {
          if (refreshVerify(refreshToken)) {
            // a ok, r ok
            req.auth = decodedToken;
            return callback(null);
          } else {
            // a ok, r err
            // 1
            // const refreshToken = securityHandlers.createRefreshToken({
            //   id: decodedToken.id,
            // });
            // req.auth = {
            //   token: {
            //     accessToken: accessToken,
            //     refreshToken: refreshToken,
            //   },
            // };
            // return callback(null);

            // 2
            return req.res.status(401).json({ msg: "token expired" });
          }
        } else if (jwt.TokenExpiredError.name === verificationError.name) {
          if (refreshVerify(refreshToken)) {
            // a err, r ok
            const decodedToken = jwt.decode(refreshToken);
            const accessToken = securityHandlers.createToken({
              id: decodedToken.id,
            });
            req.auth = accessToken;
            return callback(null);
          } else {
            // a err, r err
            return req.res.status(401).json({ msg: "token expired" });
          }
        } else {
          return callback(sendError());
        }
      }
    );
  }
};

exports.createToken = function (obj) {
  const token = jwt.sign(obj, sharedSecret, {
    algorithm: "HS256",
    expiresIn: "7d",
  });
  return token;
};

exports.createRefreshToken = function (obj) {
  const token = jwt.sign(obj, sharedSecret, {
    algorithm: "HS256",
    expiresIn: "10d",
  });
  return token;
};
```

<br />
#### `auth.js`

- ë¡œê·¸ì¸ ë¡œì§

```jsx
const securityHandlers = require("../helpers/securityHandlers");
const { authConfig } = require("../../config/authConfig.js");

const auth = function () {
  const login = (req, res) => {
    const inputData = req.swagger.params.body.value;
    if (inputData.id == authConfig.id && inputData.pwd == authConfig.pwd) {
      const { accessToken, refreshToken } = makeToken({ id: inputData.id });
      res.json({
        ok: true,
        id: inputData.id,
        token: {
          accessToken: accessToken,
          refreshToken: refreshToken,
        },
      });
    } else {
      res.json({
        ok: false,
        msg: "ì•„ì´ë”” ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.",
      });
    }
  };

  const makeToken = (id) => {
    const accessToken = securityHandlers.createToken(id);
    const refreshToken = securityHandlers.createRefreshToken(id);
    return { accessToken, refreshToken };
  };

  return {
    login: login,
  };
};

module.exports = auth();
```

<br />
#### swagger.yaml ì„¤ì •

#### `default.yaml`

```jsx
_swagger_security: name: swagger_security;
securityHandlersModule: api / helpers / securityHandlers;
```

#### `swagger.yaml`

```jsx
securityDefinitions:
  Bearer:
    type: basic

paths:
  /user:
    x-swagger-router-controller: something
    get:
      security:
        - Bearer: []
```

<br />
### ui

#### `main.js`

```jsx
axios.defaults.baseURL = api;

axios.interceptors.request.use((config) => {
  if (store.state.auth.token) {
    config.headers = {
      ...config.headers,
      Authorization: `Bearer|${store.state.auth.token.accessToken}|${store.state.auth.token.refreshToken}`,
    };
  }
  return config;
});

axios.interceptors.response.use(null, (error) => {
  if (error.response.status === 401) {
    console.log(error.response.msg);
    ElementUI.Message({
      message: "ë¡œê·¸ì¸ ì¸ì¦ ê¸°ê°„ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì¬ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.",
      type: "warning",
    });
    store.dispatch("setIsAuth", false);
    router.replace("/login");
    return Promise.reject(error);
  } else if (error.response.status === 403) {
    ElementUI.Message({
      message: "ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.",
      type: "warning",
    });
    return Promise.reject(error);
  } else {
    return Promise.reject(error);
  }
});
```

<br />

## â˜€ï¸ JWT ì½”ë“œ ì ìš© 2

- axios intercentors headerì— access tokenë§Œ ë‹´ì•„ ë³´ë‚´ê³ , security handlerì˜ ì‘ë‹µì— ë”°ë¼ ë‹¤ì‹œ refresh tokenì„ ë‹´ì•„ ë³´ë‚´ëŠ” ë°©ì‹, GET ìš”ì²­ì— ëŒ€í•´ì„œëŠ” í—¤ë”ì— í† í° ë‹´ì•„ ë³´ë‚´ì§€ ì•ŠìŒ

### api

#### `secrityHandlers.js`

- ìš”ì²­ì´ ë“¤ì–´ì˜¬ ë•Œë§ˆë‹¤ í† í°ì„ ê²€ì¦, ì¬ë°œê¸‰, ì—ëŸ¬ ë°œìƒ

```jsx
const jwt = require("jsonwebtoken");
const sharedSecret = "hiJWT";
const { authConfig } = require("../../config/authConfig.js");

exports.Bearer = function (req, authOrSecDef, token, callback) {
  function sendError() {
    return new Error("access denied");
  }

  const path = req.path.split("/common/v1")[1];
  if (!req.headers.Authorization || path == "/auth/refresh") {
    return callback(null);
  } else {
    const tokenString = token.split("|")[1];
    jwt.verify(
      tokenString,
      sharedSecret,
      function (verificationError, decodedToken) {
        if (verificationError == null && decodedToken) {
          if (authConfig.issuer == decodedToken.iss) {
            req.auth = decodedToken;
            return callback(null);
          } else {
            return req.res.status(403).json({ msg: "access denied" });
          }
        } else if (jwt.TokenExpiredError.name === verificationError.name) {
          return req.res.status(401).json({ msg: "token expired" });
        }
      }
    );
  }
};

exports.refreshVerify = (token) => {
  try {
    jwt.verify(token, sharedSecret);
    return true;
  } catch (e) {
    return false;
  }
};

exports.createToken = function (obj) {
  obj.iss = authConfig.issuer;
  const token = jwt.sign(obj, sharedSecret, {
    algorithm: "HS256",
    expiresIn: "7d",
  });
  return token;
};

exports.createRefreshToken = function (obj) {
  obj.iss = authConfig.issuer;
  const token = jwt.sign(obj, sharedSecret, {
    algorithm: "HS256",
    expiresIn: "30d",
  });
  return token;
};
```

<br />
#### `auth.js`

- ë¡œê·¸ì¸ ë¡œì§

```jsx
const securityHandlers = require("../helpers/securityHandlers");
const { authConfig } = require("../../config/authConfig.js");

const auth = function () {
  const login = (req, res) => {
    const inputData = req.swagger.params.body.value;
    if (inputData.id == authConfig.id && inputData.pwd == authConfig.pwd) {
      const { accessToken, refreshToken } = makeToken({ id: inputData.id });
      res.json({
        ok: true,
        id: inputData.id,
        token: {
          accessToken: accessToken,
          refreshToken: refreshToken,
        },
      });
    } else {
      res.json({
        ok: false,
        msg: "ì•„ì´ë”” ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.",
      });
    }
  };

  const refreshVerify = (req, res) => {
    const token = req.swagger.params.body.value.refreshToken;
    if (securityHandlers.refreshVerify(token)) {
      const { accessToken, refreshToken } = makeToken({ id: authConfig.id });
      res.json({
        ok: true,
        token: {
          accessToken: accessToken,
          refreshToken: refreshToken,
        },
      });
    } else {
      return res.status(401).json({ msg: "token expired" });
    }
  };
  const makeToken = (id) => {
    const accessToken = securityHandlers.createToken(id);
    const refreshToken = securityHandlers.createRefreshToken(id);
    return { accessToken, refreshToken };
  };

  return {
    login: login,
    refreshVerify: refreshVerify,
  };
};

module.exports = auth();
```

<br />
#### swagger.yaml ì„¤ì •

#### `default.yaml`

```jsx
_swagger_security: name: swagger_security;
securityHandlersModule: api / helpers / securityHandlers;
```

#### `swagger.yaml`

```jsx
securityDefinitions:
  Bearer:
    type: apiKey
    name: Authorization
    in: header
    description: "/authì—ì„œ ë¡œê·¸ì¸ í›„ í† í°ì…ë ¥ : Bearer|[token]"

paths:
  /user:
    x-swagger-router-controller: something
    get:
      security:
        - Bearer: []
```

<br />
### ui

#### `main.js`

```jsx
axios.defaults.baseURL = api;

const axiosRefreshInstance = axios.create({
  baseURL: api,
});

axiosRefreshInstance.interceptors.request.use(
  (config) => {
    if (store.state.auth.token) {
      config.headers = {
        ...config.headers,
        Authorization: `Bearer|${store.state.auth.token.refreshToken}`,
      };
    }
    return config;
  },
  (err) => {
    console.log(err);
  }
);

axios.interceptors.request.use(
  (config) => {
    const method = config.method.toUpperCase();
    if (method != "GET") {
      if (store.state.auth.token) {
        config.headers = {
          ...config.headers,
          Authorization: `Bearer|${store.state.auth.token.accessToken}`,
        };
      }
      return config;
    } else {
      return config;
    }
  },
  (err) => {
    return Promise.reject(err);
  }
);

axios.interceptors.response.use(null, async (error) => {
  if (error.response.status == 401) {
    const originConfig = error.response.config;
    try {
      const response = await axiosRefreshInstance.post("/auth/refresh", {
        refreshToken: store.state.auth.token.refreshToken,
      });
      if (response.data.token) {
        store.dispatch("setIsAuth", {
          isAuth: true,
          token: response.data.token,
        });
        originConfig.headers.Authorization = `Bearer|${response.data.token.accessToken}`;
        return axios.request(originConfig);
      }
    } catch (error) {
      ElementUI.Message({
        message: "ë¡œê·¸ì¸ ì¸ì¦ ê¸°ê°„ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì¬ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.",
        type: "warning",
      });
      store.dispatch("setIsAuth", false);
      router.replace("/login");
      return Promise.reject(error);
    }
  } else if (error.response.status == 403 && error.response.data.msg) {
    ElementUI.Message({
      message: "ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.",
      type: "warning",
    });
    store.dispatch("setIsAuth", false);
    router.replace("/login");
    return Promise.reject(error);
  } else {
    return Promise.reject(error);
  }
});
```

<br />

## â˜€ï¸ JWT ì½”ë“œ ì ìš© 3

- axios intercentors headerì— access tokenë§Œ ë‹´ì•„ ë³´ë‚´ê³ 
- security handlerì˜ ì‘ë‹µì— ë”°ë¼ ë‹¤ì‹œ refresh tokenì„ ë‹´ì•„ ë³´ë‚´ëŠ” ë°©ì‹
- ëª¨ë“  ìš”ì²­ì— ëŒ€í•´ í† í° ë‹´ì•„ ë³´ëƒ„

### api

#### `secrityHandlers.js`

- ìš”ì²­ì´ ë“¤ì–´ì˜¬ ë•Œë§ˆë‹¤ í† í°ì„ ê²€ì¦, ì¬ë°œê¸‰, ì—ëŸ¬ ë°œìƒ

```jsx
const jwt = require("jsonwebtoken");
const sharedSecret = "hiJWT";
const { authConfig } = require("../../config/authConfig.js");

exports.Bearer = function (req, authOrSecDef, token, callback) {
  const path = req.path.split("/common/v1")[1];

  if (path == "/auth" || path == "/auth/refresh") {
    return callback(null);
  } else if (req.headers.authorization) {
    const tokenString = token.split("|")[1];
    // token ê²€ì¦
    jwt.verify(
      tokenString,
      sharedSecret,
      function (verificationError, decodedToken) {
        if (verificationError == null && decodedToken) {
          // ìœ íš¨ í† í°ì¼ ë•Œ
          if (authConfig.issuer == decodedToken.iss) {
            req.auth = decodedToken;
            return callback(null);
          } else {
            return req.res.status(403).json({ msg: "access denied" });
          }
        } else if (jwt.TokenExpiredError.name === verificationError.name) {
          // ë§Œë£Œ í† í°ì¼ ë•Œ
          return req.res.status(401).json({ msg: "token expired" });
        }
      }
    );
  } else {
    // !req.headers.authorization
    return req.res.status(403).json({ msg: "access denied" });
  }
};

exports.refreshVerify = (token) => {
  try {
    jwt.verify(token, sharedSecret);
    return true;
  } catch (e) {
    return false;
  }
};

exports.createToken = function (obj) {
  obj.iss = authConfig.issuer;
  const token = jwt.sign(obj, sharedSecret, {
    algorithm: "HS256",
    expiresIn: "7d",
  });
  return token;
};

exports.createRefreshToken = function (obj) {
  obj.iss = authConfig.issuer;
  const token = jwt.sign(obj, sharedSecret, {
    algorithm: "HS256",
    expiresIn: "30d",
  });
  return token;
};
```

<br />
#### `auth.js`

- ë¡œê·¸ì¸ ë¡œì§

```jsx
const securityHandlers = require("../helpers/securityHandlers");
const { authConfig } = require("../../config/authConfig.js");

const auth = function () {
  const login = (req, res) => {
    const inputData = req.swagger.params.body.value;
    if (inputData.id == authConfig.id && inputData.pwd == authConfig.pwd) {
      const { accessToken, refreshToken } = makeToken({ id: inputData.id });
      res.json({
        ok: true,
        id: inputData.id,
        token: {
          accessToken: accessToken,
          refreshToken: refreshToken,
        },
      });
    } else {
      res.json({ ok: false, msg: "ì•„ì´ë”” ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤." });
    }
  };

  const refreshVerify = (req, res) => {
    const token = req.swagger.params.body.value.refreshToken;
    if (securityHandlers.refreshVerify(token)) {
      const { accessToken, refreshToken } = makeToken({ id: authConfig.id });
      res.json({
        ok: true,
        token: {
          accessToken: accessToken,
          refreshToken: refreshToken,
        },
      });
    } else {
      return res.status(401).json({ msg: "token expired" });
    }
  };
  const makeToken = (id) => {
    const accessToken = securityHandlers.createToken(id);
    const refreshToken = securityHandlers.createRefreshToken(id);
    return { accessToken, refreshToken };
  };

  return {
    login: login,
    refreshVerify: refreshVerify,
  };
};

module.exports = auth();
```

#### swagger.yaml ì„¤ì •

`default.yaml`

```jsx
_swagger_security: name: swagger_security;
securityHandlersModule: api / helpers / securityHandlers;
```

<br />
`swagger.yaml`

```jsx
securityDefinitions:
  Bearer:
    type: apiKey
    name: Authorization
    in: header
    description: "/authì—ì„œ ë¡œê·¸ì¸ í›„ í† í°ì…ë ¥ : Bearer|[token]"

paths:
  /user:
    x-swagger-router-controller: something
    get:
      security:
        - Bearer: []
```

<br />
#### ui

`main.js`

```jsx
axios.defaults.baseURL = api;

const axiosRefreshInstance = axios.create({
  baseURL: api,
});

// refresh interceptors
axiosRefreshInstance.interceptors.request.use(
  (config) => {
    if (store.state.auth.token) {
      config.headers = {
        ...config.headers,
        authorization: `Bearer|${store.state.auth.token.refreshToken}`,
      };
    }
    return config;
  },
  (err) => {
    console.log(err);
  }
);

// origin interceptors
axios.interceptors.request.use(
  (config) => {
    if (store.state.auth.token) {
      config.headers = {
        ...config.headers,
        authorization: `Bearer|${store.state.auth.token.accessToken}`,
      };
      return config;
    } else {
      return config;
    }
  },
  (err) => {
    return Promise.reject(err);
  }
);

axios.interceptors.response.use(null, async (error) => {
  if (error.response.status == 401) {
    const originConfig = error.response.config;
    try {
      // refreshToken ê²€ì¦
      const response = await axiosRefreshInstance.post("/auth/refresh", {
        refreshToken: store.state.auth.token.refreshToken,
      });
      if (response.data.token) {
        store.dispatch("setIsAuth", {
          isAuth: true,
          token: response.data.token,
        });
        originConfig.headers.authorization = `Bearer|${response.data.token.accessToken}`;
        return axios.request(originConfig);
      }
    } catch (error) {
      ElementUI.Message({
        message: "ë¡œê·¸ì¸ ì¸ì¦ ê¸°ê°„ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì¬ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.",
        type: "warning",
      });
      store.dispatch("setIsAuth", false);
      router.replace("/login");
      return Promise.reject(error);
    }
  } else if (error.response.status == 403 && error.response.data.msg) {
    ElementUI.Message({
      message: "ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.",
      type: "warning",
    });
    store.dispatch("setIsAuth", false);
    router.replace("/login");
    return Promise.reject(error);
  } else {
    return Promise.reject(error);
  }
});
```

## <br />

## ğŸ“š ì°¸ê³ 

[ì¸í„°ì…‰í„°](https://axios-http.com/kr/docs/interceptors)

[ì‰½ê²Œ ì•Œì•„ë³´ëŠ” ì„œë²„ ì¸ì¦ 2í¸(Access Token + Refresh Token)](https://tansfil.tistory.com/59)

[[WEB] ğŸ“š Access Token & Refresh Token ì›ë¦¬ (feat. JWT)](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-Access-Token-Refresh-Token-%EC%9B%90%EB%A6%AC-feat-JWT)

[Expressì—ì„œ JWTë¡œ ì¸ì¦ì‹œìŠ¤í…œ êµ¬í˜„í•˜ê¸° ( Access Tokenê³¼ Refresh Token )](https://velog.io/@kshired/Express%EC%97%90%EC%84%9C-JWT%EB%A1%9C-%EC%9D%B8%EC%A6%9D%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-Access-Token%EA%B3%BC-Refresh-Token)

[í† ê·¼ ê¸°ë°˜ ì¸ì¦ì—ì„œ bearerëŠ” ë¬´ì—‡ì¼ê¹Œ?](https://velog.io/@cada/%ED%86%A0%EA%B7%BC-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D%EC%97%90%EC%84%9C-bearer%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)

[MDSì¸í…”ë¦¬ì „ìŠ¤ ë¸”ë¡œê·¸ : ë„¤ì´ë²„ ë¸”ë¡œê·¸](https://blog.naver.com/mds_datasecurity/222182943542)
